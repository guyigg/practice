<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>浏览器底层渲染机制</title>
    <script src="../jsBasis/fn/RegExp_tool.js"></script>
</head>
<body>
    
</body>
<script>
    /**
     * CRP:critical rendering path 关键渲染路径
     *  围绕渲染的机制和步骤，去详细的进行每一步的优化，以此来提高页面的渲速度和运行性能
     * 
     * 从服务器基于HTTP网路请求回来的数据
     *  + 服务器返回的是16进制流文件
     *  + 浏览器把它解析为字符串（html字符串）
     *  + 然后按照W3C规则把它们识别成一个个节点「词法解析」
     *  + 最后生成DOM/CSS...树
     * 
     * 访问页面，首先请求回来的是一个HTML文档，浏览器开始自上而下渲染
     *  + 进程：一般指一个程序（浏览器打开一个页面就相当于打开了一个程序）
     *  + 线程：进程中具体去实现事务的东西，一个线程同时只能干一件事情
     *  + 一个进程中，可以有N多个线程
     * 
     * 同步编程：一般是只有一个线程去处理事情，上面的事情处理不完，下面的事情无法处理「一件事一件事去干」
     * 异步编程：
     *  + 多线程异步编程
     *  + 单线程异步编程「JS是EventQueue+EventLoop机制来完成单线程异步编程的」
     *  + ...
     * 
     * 浏览器是可以开辟多个进程/线程的
     *  + GUI渲染线程：渲染页面
     *  + JS引擎线程：渲染解析JS代码的
     *  + HTTP网络线程，可以开辟很多个：从服务器获取数据资源的
     *  + 定时器监听线程
     *  + DOM监听线程
     *  + ...
     * 
     * 渲染页面过程中
     *  + 遇到style内嵌样式，直接渲染即可（同步的）
     *     ->如果样式比较少是建议用内嵌样式的，拉取完HTML样式也跟着返回来，这样子减少渲染时间
     *     ->如果样式很多，则建议用link外链。如果还用内嵌，影响拉取HTML时间，样式也不好维护。
     *  + 遇到link标签，，浏览器开辟一个HTTP线程去获取资源，GUI渲染线程不会被阻塞继续向下渲染（异步的）
     *    + 浏览器同时能够发送的HTTP请求是有数量限制的 （谷歌：5～7个）
     *    + 超过最大并发限制的HTTP请求需要排队等待
     *     ->HTTP网络请求一定是越少越好
     *  + 遇到@import，浏览器也是开辟一个HTTP线程去获取资源，此时GUI渲染会暂停（导入式样式会阻塞GUI渲染），当资源请求回来后GUI渲染再继续（同步的）
     *     ->所以在实际项目中不建议用@import
     * 
     *  + 遇到<script src="xxx">会阻碍GUI渲染
     *    + defer属性：请求JS资源是异步的「单独开辟HTTP去请求」，和link相似不会阻碍GUI渲染，等待GUI渲染完了才会去处理js渲染
     *    + async属性：请求JS资源是异步的「单独开辟HTTP去请求」，此时GUI继续渲染；但是当js请求回来了会立即暂停GUI渲染，接下来渲染完请求回来的js后再继续GUI渲染
     *      ->假如我们有5个JS的请求，不设置任何属性是按照先后顺序去请求和渲染的（依赖关系是有效的）；设置了async就是谁先请求回来就先渲染谁，依赖关系是无效的；设置了defer是可以建立依赖关系的(浏览器内部在GUI渲染完成后，等待所有设置defer的资源都请求回来，再按照编写的依赖顺序去加载渲染js)
     * 
     *  真实项目开发，我们一般把link放在页面的头部「是为了在没有渲染DOM的时候，就通知HTTP去请求CSS了，这样DOM渲染完，CSS也差不多回来了，更有效的利用时间，提高页面的渲染速度」；我们一般把JS放在页面的底部，防止其阻碍GUI的渲染，如果不放在底部，我们最好设置上async/defer...；
     * 
     * 下面就是常规的一个页面渲染流程
     * DOM TREE（渲染完DOMContentLoaded事件触发）->「执行js」?-> CSSOM TREE -> RENDER TREE渲染树「浏览器未来是按照这个树来绘制页面的」-> Layout布局计算「回流/重排」-> Painting绘制「重绘」{ 分层绘制 }删格系统
     *  + 页面第一次渲染，必然会引发一次回流和重绘
     *  + 如果我们改变了元素的位置和大小，浏览器需要重新计算元素在视口中的位置和大小信息，重新计算的过程是回流/重排，一但发生了回流操作，一定也会触发重绘「很消耗性能：DOM操作消耗性能，90%说的都是它」
     *  + 但是如果只是一些普通样式的改变，位置和大小不变，只需要重绘即可
     *  改变大小、位置会影响回流（重排、重绘）
     *  改变背景颜色、字体颜色会影响绘制（重绘）
     * 
     * + 新版浏览器都有一个机制：渲染队列机制
     *   把修改样式的操作依次放入渲染队列里面，当没有修改样式的代码或者遇到了获取样式的代码时都会重新刷新渲染队列（把队列中的样式统一修改和渲染一次，引发一次回流和重绘）
    */
   /**
    * 知识点： URI：统一资源标识符 -> URL:统一资源定位符；URN:统一资源名称
    * 输入URL到看到页面，中间经历的环节
    * 1、URL解析
   */
</script>
</html>